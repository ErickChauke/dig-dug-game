#include "TerrainGrid.h"
#include <fstream>
#include <iostream>

TerrainGrid::TerrainGrid() : levelLoaded(false) {
    // Initialize all blocks as solid first
    for (int x = 0; x < WORLD_WIDTH; x++) {
        for (int y = 0; y < WORLD_HEIGHT; y++) {
            blocks[x][y] = BlockType::SOLID;
        }
    }
    
    // Try to load from file, fall back to default if it fails
    if (!loadFromFile("resources/level1.txt")) {
        std::cout << "Level file not found, creating default level with visible rocks..." << std::endl;
        createDefaultLevel();
    }
    
    levelLoaded = true;
}

bool TerrainGrid::loadFromFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cout << "Could not open level file: " << filename << std::endl;
        return false;
    }
    
    std::string line;
    int y = 0;
    
    // Clear existing data
    initialRockPositions.clear();
    monsterPositions.clear();
    playerStartPosition = Position(39, 6); // Default from level file
    
    std::cout << "Loading level from: " << filename << std::endl;
    
    while (std::getline(file, line) && y < WORLD_HEIGHT) {
        // Skip comment lines and empty lines
        if (line.empty() || line[0] == '#') {
            continue;
        }
        
        // Ensure line is long enough
        if (line.length() < WORLD_WIDTH) {
            line.resize(WORLD_WIDTH, 'W'); // Pad with walls
        }
        
        for (int x = 0; x < WORLD_WIDTH && x < (int)line.length(); x++) {
            char c = line[x];
            Position pos(x, y);
            
            switch (c) {
                case 'W':
                    blocks[x][y] = BlockType::SOLID;
                    break;
                case '.':
                    blocks[x][y] = BlockType::EMPTY;
                    break;
                case 'R':
                    blocks[x][y] = BlockType::ROCK;
                    initialRockPositions.push_back(pos);
                    std::cout << "ROCK LOADED at (" << pos.x << ", " << pos.y << ")" << std::endl;
                    break;
                case 'P':
                    blocks[x][y] = BlockType::EMPTY;
                    playerStartPosition = pos;
                    std::cout << "Player start position: (" << pos.x << ", " << pos.y << ")" << std::endl;
                    break;
                case 'M':
                    blocks[x][y] = BlockType::EMPTY;
                    monsterPositions.push_back(pos);
                    std::cout << "Monster position: (" << pos.x << ", " << pos.y << ")" << std::endl;
                    break;
                case 'D':
                    blocks[x][y] = BlockType::EMPTY;
                    monsterPositions.push_back(pos);
                    std::cout << "Dragon position: (" << pos.x << ", " << pos.y << ")" << std::endl;
                    break;
                default:
                    blocks[x][y] = BlockType::SOLID;
                    break;
            }
        }
        y++;
    }
    
    file.close();
    
    // Validate level data
    if (!validateLevelData()) {
        std::cout << "Level validation failed, using default level" << std::endl;
        return false;
    }
    
    std::cout << "Level loaded successfully:" << std::endl;
    std::cout << "- Rocks: " << initialRockPositions.size() << std::endl;
    std::cout << "- Monsters: " << monsterPositions.size() << std::endl;
    std::cout << "- Player start: (" << playerStartPosition.x << ", " << playerStartPosition.y << ")" << std::endl;
    
    return true;
}

void TerrainGrid::triggerRockFall(const Position& rockPos) {
    if (isBlockRock(rockPos)) {
        triggeredRockFalls.push_back(rockPos);
        std::cout << "Rock fall triggered at (" << rockPos.x << ", " << rockPos.y << ")" << std::endl;
    }
}

std::vector<Position> TerrainGrid::getTriggeredRockFalls() {
    std::vector<Position> result = triggeredRockFalls;
    triggeredRockFalls.clear();  // Clear after returning
    return result;
}

bool TerrainGrid::isBlockSolid(const Position& pos) const {
    if (!isValidPosition(pos)) {
        return true;
    }
    return blocks[pos.x][pos.y] == BlockType::SOLID;
}

bool TerrainGrid::isBlockRock(const Position& pos) const {
    if (!isValidPosition(pos)) {
        return false;
    }
    return blocks[pos.x][pos.y] == BlockType::ROCK;
}

bool TerrainGrid::isBlockEmpty(const Position& pos) const {
    if (!isValidPosition(pos)) {
        return false;
    }
    return blocks[pos.x][pos.y] == BlockType::EMPTY;
}

BlockType TerrainGrid::getBlockType(const Position& pos) const {
    if (!isValidPosition(pos)) {
        return BlockType::SOLID;
    }
    return blocks[pos.x][pos.y];
}

void TerrainGrid::digTunnelAt(const Position& pos) {
    if (isValidPosition(pos)) {
        blocks[pos.x][pos.y] = BlockType::EMPTY;
    }
}

void TerrainGrid::setBlock(const Position& pos, BlockType type) {
    if (isValidPosition(pos)) {
        blocks[pos.x][pos.y] = type;
    }
}

bool TerrainGrid::isValidPosition(const Position& pos) const {
    return pos.x >= 0 && pos.x < WORLD_WIDTH && 
           pos.y >= 0 && pos.y < WORLD_HEIGHT;
}

void TerrainGrid::removeRockAt(const Position& pos) {
    if (isValidPosition(pos) && isBlockRock(pos)) {
        setBlock(pos, BlockType::EMPTY);
    }
}

void TerrainGrid::draw() const {
    for (int x = 0; x < WORLD_WIDTH; x++) {
        for (int y = 0; y < WORLD_HEIGHT; y++) {
            Position worldPos(x, y);
            Position pixelPos = worldPos.toPixels();
            raylib::Color blockColor = getBlockColor(worldPos);
            
            DrawRectangle(pixelPos.x, pixelPos.y,
                         Position::BLOCK_SIZE, Position::BLOCK_SIZE,
                         blockColor);
        }
    }
}

void TerrainGrid::createDefaultLevel() {
    std::cout << "Creating authentic Dig Dug level with narrow tunnels..." << std::endl;
    
    // Initialize ground level - sky above row 3
    for (int x = 0; x < WORLD_WIDTH; x++) {
        for (int y = 0; y < 3; y++) {
            blocks[x][y] = BlockType::EMPTY;
        }
    }
    
    // Ground level (row 3 and below are solid earth)
    for (int x = 0; x < WORLD_WIDTH; x++) {
        for (int y = 3; y < WORLD_HEIGHT; y++) {
            blocks[x][y] = BlockType::SOLID;
        }
    }
    
    // Create NARROW vertical tunnel from surface
    blocks[20][3] = BlockType::EMPTY;  // Surface entrance
    blocks[20][4] = BlockType::EMPTY;
    blocks[20][5] = BlockType::EMPTY;
    blocks[20][6] = BlockType::EMPTY;
    blocks[20][7] = BlockType::EMPTY;
    blocks[20][8] = BlockType::EMPTY;
    blocks[20][9] = BlockType::EMPTY;
    blocks[20][10] = BlockType::EMPTY;
    blocks[20][11] = BlockType::EMPTY;
    blocks[20][12] = BlockType::EMPTY;
    blocks[20][13] = BlockType::EMPTY;
    blocks[20][14] = BlockType::EMPTY;
    
    // Create NARROW horizontal tunnels where monsters live
    // Upper tunnel
    for (int x = 10; x < 30; x++) {
        blocks[x][15] = BlockType::EMPTY;
    }
    
    // Lower tunnel  
    for (int x = 10; x < 30; x++) {
        blocks[x][25] = BlockType::EMPTY;
    }
    
    // Connect vertical to horizontal tunnels
    blocks[20][15] = BlockType::EMPTY;
    blocks[20][16] = BlockType::EMPTY;
    blocks[20][17] = BlockType::EMPTY;
    blocks[20][18] = BlockType::EMPTY;
    blocks[20][19] = BlockType::EMPTY;
    blocks[20][20] = BlockType::EMPTY;
    blocks[20][21] = BlockType::EMPTY;
    blocks[20][22] = BlockType::EMPTY;
    blocks[20][23] = BlockType::EMPTY;
    blocks[20][24] = BlockType::EMPTY;
    blocks[20][25] = BlockType::EMPTY;
    
    // Set player start position
    playerStartPosition = Position(20, 3);  // Start at surface
    
    // Add monsters in the narrow tunnels
    monsterPositions.clear();
    monsterPositions.push_back(Position(25, 15));  // In upper tunnel
    monsterPositions.push_back(Position(15, 25));  // In lower tunnel
    
    // CRITICAL: Place rocks ABOVE tunnels in solid earth where they can fall
    initialRockPositions.clear();
    
    // Rocks above upper tunnel - these will fall when player digs below them
    Position rock1(15, 14);  // Above upper tunnel
    Position rock2(25, 14);  // Above upper tunnel  
    
    // Rocks above lower tunnel - these will fall when player digs below them
    Position rock3(15, 24);  // Above lower tunnel
    Position rock4(25, 24);  // Above lower tunnel
    
    // Rock above vertical tunnel
    Position rock5(20, 7);   // In vertical tunnel path
    
    initialRockPositions.push_back(rock1);
    initialRockPositions.push_back(rock2);
    initialRockPositions.push_back(rock3);
    initialRockPositions.push_back(rock4);
    initialRockPositions.push_back(rock5);
    
    // IMPORTANT: Actually place rocks in terrain blocks
    for (const auto& rockPos : initialRockPositions) {
        if (rockPos.isValid()) {
            blocks[rockPos.x][rockPos.y] = BlockType::ROCK;
            std::cout << "ROCK PLACED at (" << rockPos.x << ", " << rockPos.y << ") - will fall when dug below!" << std::endl;
        }
    }
    
    std::cout << "Authentic Dig Dug level created with:" << std::endl;
    std::cout << "- " << monsterPositions.size() << " monsters in narrow tunnels" << std::endl;
    std::cout << "- " << initialRockPositions.size() << " rocks positioned to fall strategically" << std::endl;
    std::cout << "- Player starts at surface (" << playerStartPosition.x << ", " << playerStartPosition.y << ")" << std::endl;
    std::cout << "- Narrow tunnel system like authentic Dig Dug!" << std::endl;
}

void TerrainGrid::initializeGroundLevel() {
    // This method is no longer used - createDefaultLevel handles everything
}

bool TerrainGrid::validateLevelData() const {
    // Check if player start position is valid
    if (!playerStartPosition.isValid()) {
        std::cout << "Invalid player start position" << std::endl;
        return false;
    }
    
    // Check if we have at least one monster
    if (monsterPositions.empty()) {
        std::cout << "No monsters found in level" << std::endl;
        return false;
    }
    
    // Validate monster positions
    for (const auto& pos : monsterPositions) {
        if (!pos.isValid()) {
            std::cout << "Invalid monster position: (" << pos.x << ", " << pos.y << ")" << std::endl;
            return false;
        }
    }
    
    return true;
}

raylib::Color TerrainGrid::getBlockColor(const Position& pos) const {
    switch (blocks[pos.x][pos.y]) {
        case BlockType::SOLID:
            return raylib::Color(139, 69, 19, 255); // Brown
        case BlockType::EMPTY:
            return raylib::Color(0, 0, 0, 255); // Black
        case BlockType::ROCK:
            return raylib::Color(128, 128, 128, 255); // Gray - ROCKS SHOULD BE VISIBLE
        default:
            return raylib::Color(0, 0, 0, 255); // Black
    }
}
